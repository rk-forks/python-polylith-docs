{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"What's Polylith?","text":"<p>Polylith is an architecture, with tooling support, originally built for Clojure. This project brings Polylith to Python.</p> <p>From the official Polylith Architecture docs:</p> <p>... Polylith is a software architecture that applies functional thinking at the system scale. It helps us build simple, maintainable, testable, and scalable backend systems. ...</p>"},{"location":"#well-suited-for-monorepos","title":"Well suited for Monorepos","text":"<p>Polylith is using a components-first architecture. You can think of it as building blocks, very much like LEGO bricks. The Python code is separated from the infrastructure and the building of artifacts. This may sound complicated, but it isn't.</p> <p>In short, Polylith is about:</p> <ul> <li>Viewing code as bricks, that can be combined into features</li> <li>Making it easy to reuse code across apps, tools, serverless functions and services</li> <li>Keeping it simple</li> </ul>"},{"location":"#what-problems-does-polylith-solve","title":"What problems does Polylith solve?","text":"<p>Polylith offers a solution to the Microservice vs Monolith tradeoffs. Microservices are great, but the standard kind of setup will probably introduce a new set of problems:</p> <ul> <li>Source code is spread out in several repositories.</li> <li>Duplicated code.</li> <li>Shared code need to be packaged as libraries - that means even more repositories.</li> <li>Microservices running different versions of tools and dependencies, potentially also different Python versions.</li> </ul> <p>Phew, that's a lot to maintain.</p> <p>A Monorepo addresses these types of issues, and Polylith comes with simplistic solutions to them. In addition to that, Polylith is very much about the Developer Experience. It has support for REPL Driven Development - a workflow that makes coding both joyful and interactive.</p> <p>This type of Architecture will also let you postpone design decisions, like going for a Monolith or REST Microservices or Serverless functions. Your team can instead choose to focus on writing code and creating features. Make the decisions on how to deploy when you are ready for it.</p> <p>If you can improve just one thing in your software development, make it getting faster feedback. 2</p>"},{"location":"#structure-for-simplicity","title":"Structure for simplicity","text":"<p>Organizing, sorting and structuring things is difficult. Is there one folder structure to rule them all?</p> <p>There should be one-- and preferably only one --obvious way to do it. 1</p> <p>A good folder structure is one that makes it simple to reuse existing code and makes it easy to add new code. You shouldn't have to worry about these things. The Polylith Architecture offers a way to organize code that is simple, framework agnostic and scalable as projects grow. See The Polylith Workspace for how such a structure looks like.</p>"},{"location":"#it-is-all-about-the-bricks","title":"It is all about the bricks","text":"<p>The main takeaway is to view code as small, reusable bricks, that ideally does one thing only. A brick is not the same thing as a library. So, what's the difference? Well, a library is a full blown feature. A brick can be a single function, or a parser. It can also be a thin wrapper around a third party tool.</p> <p>Simple is better than complex. 1</p> <p>In Python, a file is a module. One or more modules in a folder becomes a package. A good thing with this is that the code will be namespaced when importing it. Where does the idea of bricks fit in here? Well, a brick is a Python namespace package. Simple as that.</p> <p>Namespaces are one honking great idea -- let's do more of those! 1</p> <p>If you want to dig a bit deeper, you will find a lot more information about the Polylith Architecture in general from the official docs.</p>"},{"location":"#polylith-for-python","title":"Polylith for Python?","text":"<p>The Python tools for the Polylith Architecture is built as a Poetry plugin. The plugin will add Polylith specific features to Poetry.</p>"},{"location":"#use-cases","title":"Use cases","text":""},{"location":"#microservices-and-apps","title":"Microservices and apps","text":"<p>The main use case is to support having one or more microservices (or apps) in a Monorepo, and share code between the services.</p>"},{"location":"#libraries","title":"Libraries","text":"<p>Polylith for Python has support for building libraries to be published at PyPI, even if it isn't the main use case. More details about how to package libraries in Packaging &amp; deploying.</p> <ol> <li> <p>From the Zen of Python\u00a0\u21a9\u21a9\u21a9</p> </li> <li> <p>Dave Farley on twitter \u21a9</p> </li> </ol>"},{"location":"commands/","title":"Commands","text":""},{"location":"commands/#create-a-workspace","title":"Create a workspace","text":"<p>This will create a Polylith workspace, with a basic Polylith folder structure.</p> <pre><code>poetry poly create workspace --name my_example_namespace --theme loose\n</code></pre>"},{"location":"commands/#options","title":"Options","text":"<p><code>--name</code> (required) the workspace name, that will be used as the single top namespace for all bricks. Choose the name wisely. Have a look in PEP-423 for naming guidelines.</p> <p><code>--theme</code> the structure of the workspace (see below).</p>"},{"location":"commands/#themes","title":"Themes","text":"<p>Themes are an exclusive Python Polylith feature, and defines what kind of workspace structure to use.</p>"},{"location":"commands/#loose-recommended","title":"loose (recommended)","text":"<p>A theme to use for a more familiar structure for Python: components/namespace/package and will put a test folder at the root of the repository.</p>"},{"location":"commands/#tdd","title":"tdd","text":"<p>The default and will set the structure according to the original Polylith Clojure implementation, such as: components/package/src/namespace/package with a corresponding test folder.</p>"},{"location":"commands/#create-a-component","title":"Create a component","text":"<p>This command will create a component - i.e. a Python package in a namespaced folder.</p> <pre><code>poetry poly create component --name my_example_component\n</code></pre>"},{"location":"commands/#options_1","title":"Options","text":"<p><code>--name</code> (required) the name of the component.</p> <p><code>--description</code> adding a docstring to the base. It will also be added in the README, when enabled in the configuration. See configuration.</p>"},{"location":"commands/#create-a-base","title":"Create a base","text":"<p>This command will create a base - i.e. a Python package in a namespaced folder.</p> <pre><code>poetry poly create base --name my_example_base\n</code></pre>"},{"location":"commands/#options_2","title":"Options","text":"<p><code>--name</code> (required) the name of the base.</p> <p><code>--description</code> adding a docstring to the base. It will also be added in the README, when enabled in the configuration. See configuration.</p>"},{"location":"commands/#create-a-project","title":"Create a project","text":"<p>This command will create a project - i.e. a pyproject.toml in a project folder.</p> <pre><code>poetry poly create project --name my_example_project\n</code></pre>"},{"location":"commands/#options_3","title":"Options","text":"<p><code>--name</code> (required) the name of the project.</p> <p><code>--description</code> adding a pyproject.toml description.</p>"},{"location":"commands/#info","title":"Info","text":"<p>Show info about the workspace:</p> <pre><code>poetry poly info\n</code></pre>"},{"location":"commands/#diff","title":"Diff","text":"<p>Shows what has changed since the most recent stable point in time:</p> <pre><code>poetry poly diff\n</code></pre> <p>The <code>diff</code> command will compare the current state of the repository, compared to a <code>git tag</code>. The tool will look for the latest tag according to a certain pattern, such as <code>stable-*</code>. The pattern can be configured in <code>workspace.toml</code>.</p> <p>The <code>diff</code> command is useful in a CI environment, to determine if a project should be deployed or not. The command has a <code>--short</code> flag to only print a comma separated list of changed projects to the standard output.</p> <p>Useful for CI: <pre><code>poetry poly diff --short\n</code></pre></p>"},{"location":"commands/#libs","title":"Libs","text":"<p>Show info about the third-party libraries used in the workspace:</p> <pre><code>poetry poly libs\n</code></pre> <p>This feature relies on installed project dependencies, and expects a <code>poetry.lock</code> of a project to be present. If missing, there is a Poetry command available: <pre><code>poetry lock --directory path/to-project\n</code></pre></p>"},{"location":"commands/#options_4","title":"Options","text":"<p><code>--directory</code> Show info about libraries used in a specific project.</p>"},{"location":"commands/#check","title":"Check","text":"<p>Validates the Polylith workspace, checking for any missing dependencies (bricks and third-party libraries):</p> <pre><code>poetry poly check\n</code></pre> <p>This feature is built on top of the <code>poetry poly libs</code> command, and expects a <code>poetry.lock</code> of a project to be present.</p>"},{"location":"commands/#options_5","title":"Options","text":"<p><code>--directory</code> Show info about libraries used in a specific project.</p>"},{"location":"commands/#sync","title":"Sync","text":"<p>Keep projects in sync with the actual usage of bricks in source code.</p> <pre><code>poetry poly sync\n</code></pre> <p>This feature is useful for keeping projects in sync. The command will analyze code and add any missing bricks to the projects, including the development project.</p> <ul> <li>projects: will add missing bricks to the project specific pyproject.toml, when imported by any of the already added bricks.</li> <li>development: will add all missing bricks to the development pyproject.toml.</li> </ul>"},{"location":"commands/#options_6","title":"Options","text":"<p><code>--directory</code> Synchronize a specific project.</p>"},{"location":"configuration/","title":"Configuration","text":"<p>The Polylith Workspace is configured using a workspace.toml file at the root of the workspace.</p> <p>A default configuration is created when running the <code>poetry poly create workspace</code> command (see the commands section).</p> <p>An example of a workspace configuration:</p> <pre><code>[tool.polylith]\nnamespace = \"my_example_namespace\"\ngit_tag_pattern = \"stable-*\"\n[tool.polylith.structure]\ntheme = \"loose\"\n[tool.polylith.resources]\nbrick_docs_enabled = false\n[tool.polylith.test]\nenabled = true\n</code></pre>"},{"location":"configuration/#components-and-bases-documentation","title":"Components and bases documentation","text":"<p>When <code>brick_docs_enabeld = true</code>, a README is added when creating a component or a base.</p>"},{"location":"configuration/#testing","title":"Testing","text":"<p>The create component and brick commands will also create corresponding unit tests when <code>enabled = true</code> in the test section of the workspace configuration.</p>"},{"location":"deployment/","title":"Packaging &amp; deploying","text":"<p>Packaging and deploying Polylith projects is done by using the Poetry Multiproject plugin command (see installation).</p> <p>The <code>poetry build-project</code> command will make it possible to use relative package includes as how components and bases are added to Python Polylith projects.  Relative includes are currently not possible by default in Poetry, that is where the Multiproject plugin comes in.</p>"},{"location":"deployment/#packaging","title":"Packaging","text":"<p>To collect the components and bases that are needed for a specific project, the tool introduces a build step.  The tool will build a wheel and an sdist from the source code of a project.</p> <p>This is the preferred way for Polylith projects.</p>"},{"location":"deployment/#packaging-a-service-or-app","title":"Packaging a service or app","text":"<pre><code>poetry build-project --directory path/to/project\n</code></pre> <p>This command will create a project specific dist folder containing a wheel and an sdist. You can use the default poetry build options with this command too.</p>"},{"location":"deployment/#deploying","title":"Deploying","text":"<p>You can use the built artifacts to install your service in your preffered way, just by running</p> <pre><code>pip install the-built-artifact.whl\n</code></pre>"},{"location":"deployment/#packaging-a-library","title":"Packaging a Library","text":"<p>The plugin has support for building libraries to be published at PyPI, even if it isn't the main use case. But why? By default, the code in one library will share the same top namespace with other libraries that are built from the same Polylith Monorepo. </p> <p>To solve this, there's a feature available that will organize code according to a custom top namespace and re-write the imports.</p> <p>You can choose a custom namespace to be used in the build process, by using the <code>--with-top-namespace</code> flag. This is available for Python 3.9 and above.</p> <p>The <code>build-project</code> command, with a custom top namespace:</p> <pre><code>poetry build-project --with-top-namespace my_custom_namespace\n</code></pre> <p>By using the <code>--with-top-namespace</code> flag, the built artifact will look something like this: <pre><code>my_custom_namespace/\n    /my_package\n       __init__.py\n       my_module.py\n</code></pre></p> <p>And the Python modules will have the custom top namespace as a prefix to imports: <pre><code>from my_custom_namespace.my_package import my_function\n</code></pre></p>"},{"location":"deployment/#how-is-this-done","title":"How is this done?","text":"<p>The command uses AST (Abstract Syntax Tree) parsing to modify source code. The Python built-in <code>ast</code> module is used to parse and un-parse Python code.</p>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#example-code","title":"Example code","text":"<p>Here are some examples of how to setup Python with the Polylith Architecture.</p> <ul> <li>Python Polylith Example repository by David Vujic</li> <li>Python Polylith Microservices Example by Matt Gosden</li> <li>Aws CDK App with Polylith by Yoel Ben\u00edtez Fonseca</li> </ul> <p>You will find examples of sharing code between different kind of projects, developer tooling configuration such as <code>mypy</code> and the <code>venv</code>, and development setup for REPL Driven Development or Jupyter notebooks.</p> <p>In addition to the examples, there is also the actual Python tools for the Polylith Architecture repo, that itself is a Polylith Workspace.</p>"},{"location":"examples/#looking-for-examples-and-production-systems","title":"Looking for examples and production systems","text":"<p>Do you have a Polylith repository that you or your company would like to share here? You are very much welcome to make a Pull Request, or a Github issue to the python-polylith-docs repo.</p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#install-poetry-plugins","title":"Install Poetry &amp; plugins","text":"<p>With the <code>Poetry</code> version 1.2 or later installed, you can add plugins.</p> <p>Add the Multiproject plugin, that will enable the very important Workspace support to Poetry. <pre><code>poetry self add poetry-multiproject-plugin\n</code></pre></p> <p>Add the Polylith plugin: <pre><code>poetry self add poetry-polylith-plugin\n</code></pre></p> <p>Done!</p>"},{"location":"migrating/","title":"Migrating to Polylith","text":"<p>If you decide to give Polylith a try with existing code, the suggestion is to:</p> <ul> <li>create a new repo and workspace. See setup and commands.</li> <li>choose one of your existing services or apps to migrate into the newly created Polylith repo.</li> <li>create a base with the poly tool and put all of the existing Python code in there. Don't worry, we will fix this in next steps.</li> <li>create a new project with the poly tool - this will be the project infrastructure for the service or app that currently lives in the base you added in the prevous step.</li> </ul> <p>The entrypoint for your app would be something like:</p> <pre><code>[tool.poetry]\npackages = [\n{include = \"your_namespace/your_app\", from = \"../../bases\"}\n]\n[tool.poetry.dependencies]\n# insert the needed 3rd party libraries here\n</code></pre> <p>You should now be able to run the service or app locally.</p>"},{"location":"migrating/#next-step-migrating-code-to-bricks","title":"Next step: migrating code to bricks","text":"<p>Now you are ready for the actual migration: identifying parts of the source code that could be grouped into what Polylith refers to as components. Moving them - one by one - out of the base and into new components. Add the components to the <code>pyproject.toml</code> according to the example in Projects &amp; pyproject.toml.</p>"},{"location":"migrating/#when-is-the-migration-finished","title":"When is the migration finished?","text":"<p>The base would ideally contain the entry point, and import all the needed components. You can test out the service or app, run the <code>info</code>, <code>libs</code> and <code>check</code> commands to verify all things are in place. See commands.</p> <p>Continue with your next existing service or app! By now, you should already be able to share components between your services.</p>"},{"location":"migrating/#migrating-away-from-polylith","title":"Migrating away from Polylith?","text":"<p>This step is simple.</p> <pre><code>poetry build-project --directory path/to/project\n</code></pre> <p>The output is a <code>wheel</code> and, more importantly, an <code>sdist</code> (a source distribution). It is essentially a zip file containing all source code used in the project.</p> <p>That's all!</p>"},{"location":"projects/","title":"Projects &amp; pyproject.toml","text":"<p>Projects are located in the projects folder of a Polylith workspace. Each project has its own <code>pyproject.toml</code>, where dependencies and project-specific things are defined. Just as in a mainstream Poetry project.</p> <p>What differs is how the Polylith components and bases (aka bricks) are referenced. Bricks are added in the tool.poetry section as packages:</p> <pre><code>[tool.poetry]\nname = \"my_example_project\"\npackages = [\n{include = \"my_namespace/my_base\", from = \"../../bases\"},\n{include = \"my_namespace/my_component\", from = \"../../components\"},\n{include = \"my_namespace/my_other_component\", from = \"../../components\"}\n]\n</code></pre> <p>Note the from attribute, where the base and components are referenced with relative paths. The <code>bases</code> and <code>components</code> folders are located at the workspace root. The project-specific <code>pyproject.toml</code> file is located in a subfolder of the <code>projects</code> folder.</p>"},{"location":"setup/","title":"Setup","text":""},{"location":"setup/#1-create-a-repository","title":"1. Create a repository","text":"<p>Create a directory for your code, initialize it with git and create a basic Poetry setup:</p> <pre><code>git init\n</code></pre> <pre><code>poetry init\n</code></pre> <p>From the Poetry docs:</p> <p>This command will help you create a pyproject.toml file interactively by prompting you to provide basic information about your package. It will interactively ask you to fill in the fields, while using some smart defaults.</p> <p>Next step: create a Polylith Workspace. </p>"},{"location":"setup/#2-create-a-workspace","title":"2. Create a workspace","text":"<p>Ceate a workspace, with a basic Polylith folder structure.</p> <pre><code>poetry poly create workspace --name my_namespace --theme loose\n</code></pre> <p><code>--name</code> (required) the workspace name, that will be used as the single top namespace for all bricks. Choose the name wisely. Have a look in PEP-423 for naming guidelines.</p> <p><code>--theme</code> the structure of the workspace, <code>loose</code> is the recommended structure for Python.</p>"},{"location":"setup/#3-create-a-virtual-environment","title":"3. Create a virtual environment","text":"<p>Create a virtual environment for the workspace, by running:</p> <pre><code>poetry install\n</code></pre> <p>Besides creating a virtual environment, this command will make the virtual environment aware of the <code>bases</code> and <code>components</code> folders.</p> <p>You will find more documentation about the available commands in the commands section.</p>"},{"location":"videos/","title":"Videos &amp; tutorials","text":""},{"location":"videos/#videos","title":"Videos","text":"<ul> <li>Python with the Polylith Architecture - an overview (about 15 minutes)</li> <li>Python Poetry Polylith Plugin - the tooling support &amp; commands (about 13 minutes)</li> <li>The Developer Experience - developing a Dad Joke Service with Polylith (about 27 minutes)</li> </ul>"},{"location":"videos/#articles","title":"Articles","text":"<ul> <li>The last Python Architecture you will ever need?</li> <li>A Fresh Take on Monorepos in Python</li> <li>A simple &amp; scalable Python project structure</li> <li>Aws CDK App with polylith code architecture by Yoel Ben\u00edtez Fonseca</li> </ul>"},{"location":"videos/#podcasts","title":"Podcasts","text":"<ul> <li>TalkPython: Monorepos in Python</li> </ul> <p>Got an article or video about this subject that you want to share here? You are very much welcome to make a Pull Request, or a Github issue to the python-polylith-docs repo.</p>"},{"location":"workspace/","title":"The Polylith Workspace","text":"<p>The  workspace is the root directory of a repository. The basic structure of a Polylith Workspace would look something like this:</p> <pre><code>workspace/\n  bases/\n  components/\n  development/\n  projects/\n\npoetry.lock\n\npyproject.toml\n  workspace.toml\n\nREADME.md\n</code></pre> <p>The building blocks are found in the bases and components folders. That's where the Python code is put.</p>"},{"location":"workspace/#bases","title":"bases","text":"<p>Bases are the building blocks that exposes a public API to the outside world. 1</p> <p>A base is a special kind of Polylith brick. It is where you would add the entry point of an app or a REST API. It is a bridge between the outside world and the actual features.</p>"},{"location":"workspace/#components","title":"components","text":"<p>A component is an encapsulated block of code that can be assembled together with a base (it's often just a single base) and a set of components and libraries into services, libraries or tools. Components achieve encapsulation and composability by separating their private implementation from their public interface. 1</p> <p>A component is also a brick, a building block for a feature.  It can be a \"tech\" brick, such as containing dictionary filtering helper functions, or a parser. It can also be a wrapper for a third-party library. A brick is also very likely a combination of other bricks. The combination of bricks becomes a feature. Very much like LEGO.</p>"},{"location":"workspace/#development","title":"development","text":"<p>The development folder is where you can put code that you write to experiment or try out features. It is similar to the scratch files in JetBrains PyCharm!</p> <p>The development folder is part of the development project, that is defined in the <code>pyproject.toml</code> and the <code>poetry.lock</code> file of the root folder. Here, you add all dependencies and bricks. This will make it possible to have the entire code-base available in one and the same virtual environment.</p> <p>In this folder, it is quite common that developers keep their scratch-style Python modules. It is perfectly fine to version control them. It is a place for REPL Driven Development and Jupyter Notebooks!</p> <pre><code>development/\n   sofia.py\n   david.py\n   data.ipynb\n</code></pre>"},{"location":"workspace/#projects","title":"projects","text":"<p>A project is the result of combining one base (or in rare cases several bases) with multiple components and libraries. 1</p> <p>Each project lives in a subdirectory of the <code>projects/</code> folder. A project is the deployable artifact: a microservice, a serverless function, a CLI or any kind of application.</p> <pre><code>projects/\n   my_aws_lambda/\n   my_fast_api_service/\n</code></pre> <p>In the project-specific directory, you will find a project-specific <code>pyproject.toml</code> that defines dependencies, packages and everything needed for the actual project. It is not recommended to put Python code in here. Just add the necessary project infrastructure, such as Dockerfiles and project-specific deploy scripting.</p> <ol> <li> <p>From the official Polylith Architecture documentation \u21a9\u21a9\u21a9</p> </li> </ol>"}]}